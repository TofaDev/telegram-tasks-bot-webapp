"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var InlineKeyboard_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineKeyboard = void 0;
const inspectable_1 = require("inspectable");
/** Inline keyboard */
let InlineKeyboard = InlineKeyboard_1 = class InlineKeyboard {
    constructor() {
        this.buttons = [];
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /** Assemble a builder of buttons */
    static keyboard(rows) {
        const inlineKeyboard = new InlineKeyboard_1();
        for (const row of rows) {
            inlineKeyboard.addRow(row);
        }
        return inlineKeyboard;
    }
    /** Generate text button */
    static textButton(params) {
        if (typeof params.payload === 'object') {
            params.payload = JSON.stringify(params.payload);
        }
        return {
            text: params.text,
            callback_data: params.payload || ''
        };
    }
    /** Generate URL button */
    static urlButton(params) {
        if (typeof params.payload === 'object') {
            params.payload = JSON.stringify(params.payload);
        }
        return {
            text: params.text,
            url: params.url,
            callback_data: params.payload || ''
        };
    }
    /** Generate Web App button */
    static webAppButton(params) {
        return {
            text: params.text,
            web_app: { url: params.url }
        };
    }
    /** Generate button that will switch to current chat and type the query */
    static switchToCurrentChatButton(params) {
        return {
            text: params.text,
            switch_inline_query_current_chat: params.query
        };
    }
    /** Generate button that will prompt user to select one of their chats */
    static switchToChatButton(params) {
        return {
            text: params.text,
            switch_inline_query: params.query
        };
    }
    /** Generate button that will prompt user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field */
    static switchToChosenChat(params) {
        return {
            text: params.text,
            switch_inline_query_chosen_chat: {
                query: params.query,
                allow_bot_chats: params.allowBotChats,
                allow_channel_chats: params.allowChannelChats,
                allow_group_chats: params.allowGroupChats,
                allow_user_chats: params.allowUserChats
            }
        };
    }
    /** Generate game button */
    static gameButton(params) {
        return {
            text: params.text,
            callback_game: params.game
        };
    }
    /** Generate pay button */
    static payButton(params) {
        return {
            pay: true,
            text: params.text
        };
    }
    /** Generate login button */
    static loginButton(params) {
        return {
            login_url: params.loginUrl,
            text: params.text
        };
    }
    addRow(row) {
        if (!Array.isArray(row))
            row = [row];
        this.buttons.push(row);
        return this;
    }
    /** Returns JSON which is compatible with Telegram's `InlineKeyboardMarkup` interface */
    toJSON() {
        return {
            inline_keyboard: this.buttons
        };
    }
    toString() {
        return JSON.stringify(this);
    }
};
__decorate([
    (0, inspectable_1.Inspect)({ as: 'inline_keyboard' })
], InlineKeyboard.prototype, "buttons", void 0);
InlineKeyboard = InlineKeyboard_1 = __decorate([
    (0, inspectable_1.Inspectable)()
], InlineKeyboard);
exports.InlineKeyboard = InlineKeyboard;

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chat = void 0;
const inspectable_1 = require("inspectable");
const structures_1 = require("../../common/structures");
const chat_photo_1 = require("./chat-photo");
const chat_permissions_1 = require("./chat-permissions");
const chat_location_1 = require("./chat-location");
/** This object represents a chat. */
let Chat = class Chat {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Unique identifier for this chat. This number may be greater than 32 bits
     * and some programming languages may have difficulty/silent defects in
     * interpreting it. But it is smaller than 52 bits, so a signed 64 bit
     * integer or double-precision float type are safe for storing
     * this identifier.
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Type of chat, can be either `private`, `group`, `supergroup` or `channel`
     */
    get type() {
        return this.payload.type;
    }
    /** Title, for supergroups, channels and group chats */
    get title() {
        return this.payload.title;
    }
    /** Username, for private chats, supergroups and channels if available */
    get username() {
        return this.payload.username;
    }
    /** First name of the other party in a private chat */
    get firstName() {
        return this.payload.first_name;
    }
    /** Last name of the other party in a private chat */
    get lastName() {
        return this.payload.last_name;
    }
    /** `true`, if the supergroup chat is a forum (has [topics](https://telegram.org/blog/topics-in-groups-collectible-usernames#topics-in-groups) enabled) */
    isForum() {
        return this.payload.is_forum;
    }
    /**
     * Chat photo.
     *
     * Returned only in `getChat`.
     */
    get photo() {
        const { photo } = this.payload;
        if (!photo) {
            return;
        }
        return new chat_photo_1.ChatPhoto(photo);
    }
    /**
     * If non-empty, the list of all active chat usernames; for private chats, supergroups and channels.
     *
     * Returned only in `getChat`.
     */
    get activeUsernames() {
        return this.payload.active_usernames;
    }
    /**
     * Custom emoji identifier of emoji status of the other party in a private chat.
     *
     * Returned only in `getChat`.
     */
    get emojiStatusCustomEmojiId() {
        return this.payload.emoji_status_custom_emoji_id;
    }
    /**
     * Expiration date of the emoji status of the other party in a private chat, if any.
     *
     * Returned only in `getChat`.
     */
    get emojiStatusExpirationDate() {
        return this.payload.emoji_status_expiration_date;
    }
    /**
     * Bio of the other party in a private chat.
     *
     * Returned only in `getChat`.
     */
    get bio() {
        return this.payload.bio;
    }
    /**
     * `true`, if privacy settings of the other party in the private chat allows
     * to use `tg://user?id=<user_id>` links only in chats with the user.
     *
     * Returned only in `getChat`.
     */
    hasPrivateForwards() {
        return this.payload.has_private_forwards;
    }
    /**
     * `true`, if the privacy settings of the other party restrict sending voice and video note messages in the private chat.
     *
     * Returned only in `getChat`.
     */
    hasRestrictedVoiceAndVideoMessages() {
        return this.payload.has_restricted_voice_and_video_messages;
    }
    /**
     * `true`, if users need to join the supergroup before they can send messages.
     *
     * Returned only in `getChat`.
     */
    get joinToSendMessages() {
        return this.payload.join_to_send_messages;
    }
    /**
     * `true`, if all users directly joining the supergroup need to be approved
     * by supergroup administrators.
     *
     * Returned only in `getChat`.
     */
    get joinByRequest() {
        return this.payload.join_by_request;
    }
    /**
     * For supergroups, the location to which the supergroup is connected
     *
     * Returned only in `getChat`.
     */
    get location() {
        const { location } = this.payload;
        if (!location) {
            return;
        }
        return new chat_location_1.ChatLocation(location);
    }
    /**
     * Description, for groups, supergroups and channel chats.
     *
     * Returned only in `getChat`.
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Chat invite link, for groups, supergroups and channel chats.
     * Each administrator in a chat generates their own invite links,
     * so the bot must first generate the link using `exportChatInviteLink`.
     *
     * Returned only in `getChat`.
     */
    get inviteLink() {
        return this.payload.invite_link;
    }
    /**
     * Pinned message, for groups, supergroups and channels.
     *
     * Returned only in `getChat`.
     */
    get pinnedMessage() {
        const { pinned_message } = this.payload;
        if (!pinned_message) {
            return;
        }
        return new structures_1.Message(pinned_message);
    }
    /**
     * Default chat member permissions, for groups and supergroups.
     *
     * Returned only in `getChat`.
     */
    get permissions() {
        const { permissions } = this.payload;
        if (!permissions) {
            return;
        }
        return new chat_permissions_1.ChatPermissions(permissions);
    }
    /**
     * For supergroups, the minimum allowed delay between consecutive messages
     * sent by each unpriviledged user.
     *
     * Returned only in `getChat`.
     */
    get slowModeDelay() {
        return this.payload.slow_mode_delay;
    }
    /**
     * The time after which all messages sent to the chat will be automatically deleted; in seconds.
     *
     * Returned only in `getChat`.
     */
    get messageAutoDeleteTime() {
        return this.payload.message_auto_delete_time;
    }
    /**
     * `true`, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators.
     *
     * Returned only in `getChat`.
     */
    hasAggressiveAntiSpamEnabled() {
        return this.payload.has_aggressive_anti_spam_enabled;
    }
    /**
     * `true`, if non-administrators can only get the list of bots and administrators in the chat.
     *
     * Returned only in `getChat`.
     */
    hasHiddenMembers() {
        return this.payload.has_hidden_members;
    }
    /**
     * `true`, if messages from the chat can't be forwarded to other chats.
     *
     * Returned only in `getChat`.
     */
    hasProtectedContent() {
        return this.payload.has_protected_content;
    }
    /**
     * For supergroups, name of group sticker set.
     *
     * Returned only in `getChat`.
     */
    get stickerSetName() {
        return this.payload.sticker_set_name;
    }
    /**
     * `true`, if the bot can change the group sticker set.
     *
     * Returned only in `getChat`.
     */
    canSetStickerSet() {
        return this.payload.can_set_sticker_set;
    }
    /**
     * Unique identifier for the linked chat,
     * i.e. the discussion group identifier for a channel and vice versa;
     * for supergroups and channel chats.
     * This identifier may be greater than 32 bits and some programming languages
     * may have difficulty/silent defects in interpreting it.
     * But it is smaller than 52 bits, so a signed 64 bit integer or double-precision
     * float type are safe for storing this identifier.
     *
     * Returned only in `getChat`.
     */
    get linkedChatId() {
        return this.payload.linked_chat_id;
    }
    toJSON() {
        return this.payload;
    }
};
__decorate([
    (0, inspectable_1.Inspect)()
], Chat.prototype, "id", null);
__decorate([
    (0, inspectable_1.Inspect)()
], Chat.prototype, "type", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "title", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "username", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "firstName", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "lastName", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true, nullable: false })
], Chat.prototype, "isForum", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "photo", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "activeUsernames", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "emojiStatusCustomEmojiId", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "emojiStatusExpirationDate", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "bio", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true, nullable: false })
], Chat.prototype, "hasPrivateForwards", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true, nullable: false })
], Chat.prototype, "hasRestrictedVoiceAndVideoMessages", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "joinToSendMessages", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "joinByRequest", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "location", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "description", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "inviteLink", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "pinnedMessage", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "permissions", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "slowModeDelay", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "messageAutoDeleteTime", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true, nullable: false })
], Chat.prototype, "hasAggressiveAntiSpamEnabled", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true, nullable: false })
], Chat.prototype, "hasHiddenMembers", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true, nullable: false })
], Chat.prototype, "hasProtectedContent", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "stickerSetName", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true, nullable: false })
], Chat.prototype, "canSetStickerSet", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Chat.prototype, "linkedChatId", null);
Chat = __decorate([
    (0, inspectable_1.Inspectable)()
], Chat);
exports.Chat = Chat;

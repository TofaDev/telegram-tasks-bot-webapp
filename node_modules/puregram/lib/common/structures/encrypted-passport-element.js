"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedPassportElement = void 0;
const inspectable_1 = require("inspectable");
const passport_file_1 = require("./passport-file");
/**
 * Contains information about documents or other Telegram Passport elements
 * shared with the bot by the user.
 */
let EncryptedPassportElement = class EncryptedPassportElement {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Element type. One of `personal_details`, `passport`, `driver_license`,
     * `identity_card`, `internal_passport`, `address`, `utility_bill`,
     * `bank_statement`, `rental_agreement`, `passport_registration`,
     * `temporary_registration`, `phone_number`, `email`.
     */
    get type() {
        return this.payload.type;
    }
    /**
     * Base64-encoded encrypted Telegram Passport element data provided by th
     * user, available for `personal_details`, `passport`, `driver_license`,
     * `identity_card`, `internal_passport` and `address` types.
     * Can be decrypted and verified using the accompanying
     * `EncryptedCredentials`.
     */
    get data() {
        return this.payload.data;
    }
    /** User's verified phone number, available only for `phone_number` type */
    get phoneNumber() {
        return this.payload.phone_number;
    }
    /** User's verified email address, available only for `email` type */
    get email() {
        return this.payload.email;
    }
    /**
     * Array of encrypted files with documents provided by the user, available
     * for `utility_bill`, `bank_statement`, `rental_agreement`,
     * `passport_registration` and `temporary_registration` types. Files can be
     * decrypted and verified using the accompanying `EncryptedCredentials`.
     */
    get files() {
        const { files } = this.payload;
        if (!files) {
            return;
        }
        return files.map(file => new passport_file_1.PassportFile(file));
    }
    /**
     * Encrypted file with the front side of the document, provided by the user.
     * Available for `passport`, `driver_license`, `identity_card` and
     * `internal_passport`. The file can be decrypted and verified using the
     * accompanying `EncryptedCredentials`.
     */
    get frontSide() {
        const { front_side } = this.payload;
        if (!front_side) {
            return;
        }
        return new passport_file_1.PassportFile(front_side);
    }
    /**
     * Encrypted file with the reverse side of the document, provided by the
     * user. Available for `driver_license` and `identity_card`. The file can be
     * decrypted and verified using the accompanying `EncryptedCredentials`.
     */
    get reverseSide() {
        const { reverse_side } = this.payload;
        if (!reverse_side) {
            return;
        }
        return new passport_file_1.PassportFile(reverse_side);
    }
    /**
     * Encrypted file with the selfie of the user holding a document, provided by
     * the user; available for `passport`, `driver_license`, `identity_card` and
     * `internal_passport`. The file can be decrypted and verified using the
     * accompanying `EncryptedCredentials`.
     */
    get selfie() {
        const { selfie } = this.payload;
        if (!selfie) {
            return;
        }
        return new passport_file_1.PassportFile(selfie);
    }
    /**
     * Array of encrypted files with translated versions of documents provided by
     * the user. Available if requested for `passport`, `driver_license`,
     * `identity_card`, `internal_passport`, `utility_bill`, `bank_statement`,
     * `rental_agreement`, `passport_registration` and `temporary_registration`
     * types. Files can be decrypted and verified using the accompanying
     * `EncryptedCredentials`.
     */
    get translation() {
        const { translation } = this.payload;
        if (!translation) {
            return;
        }
        return translation.map(element => new passport_file_1.PassportFile(element));
    }
    /**
     * Base64-encoded element hash for using in `PassportElementErrorUnspecified`
     */
    get hash() {
        return this.payload.hash;
    }
    toJSON() {
        return this.payload;
    }
};
__decorate([
    (0, inspectable_1.Inspect)()
], EncryptedPassportElement.prototype, "type", null);
__decorate([
    (0, inspectable_1.Inspect)()
], EncryptedPassportElement.prototype, "data", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], EncryptedPassportElement.prototype, "phoneNumber", null);
__decorate([
    (0, inspectable_1.Inspect)()
], EncryptedPassportElement.prototype, "email", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], EncryptedPassportElement.prototype, "files", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], EncryptedPassportElement.prototype, "frontSide", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], EncryptedPassportElement.prototype, "reverseSide", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], EncryptedPassportElement.prototype, "selfie", null);
__decorate([
    (0, inspectable_1.Inspect)()
], EncryptedPassportElement.prototype, "translation", null);
__decorate([
    (0, inspectable_1.Inspect)()
], EncryptedPassportElement.prototype, "hash", null);
EncryptedPassportElement = __decorate([
    (0, inspectable_1.Inspectable)()
], EncryptedPassportElement);
exports.EncryptedPassportElement = EncryptedPassportElement;

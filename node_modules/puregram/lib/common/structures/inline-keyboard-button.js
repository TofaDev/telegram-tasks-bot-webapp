"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineKeyboardButton = void 0;
const inspectable_1 = require("inspectable");
const login_url_1 = require("./login-url");
const callback_game_1 = require("./callback-game");
/** This object represents one button of an inline keyboard. You must use exactly one of the optional fields. */
let InlineKeyboardButton = class InlineKeyboardButton {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /** Label text on the button */
    get text() {
        return this.payload.text;
    }
    /** HTTP or tg:// url to be opened when button is pressed */
    get url() {
        return this.payload.url;
    }
    /**
     * An HTTP URL used to automatically authorize the user.
     * Can be used as a replacement for the Telegram Login Widget.
     */
    get loginUrl() {
        const { login_url } = this.payload;
        if (!login_url) {
            return;
        }
        return new login_url_1.LoginUrl(login_url);
    }
    /**
     * Data to be sent in a callback query to the bot when button is pressed,
     * 1-64 bytes
     */
    get callbackData() {
        return this.payload.callback_data;
    }
    /**
     * If set, pressing the button will prompt the user to select one of their
     * chats, open that chat and insert the bot's username and the specified
     * inline query in the input field. Can be empty, in which case just the
     * bot's username will be inserted.
     *
     * **Note**: This offers an easy way for users to start using your bot in
     * inline mode when they are currently in a private chat with it. Especially
     * useful when combined with `switch_pm…` actions – in this case the user will
     * be automatically returned to the chat they switched from, skipping the
     * chat selection screen.
     */
    get switchInlineQuery() {
        return this.payload.switch_inline_query;
    }
    /**
     * If set, pressing the button will insert the bot's username and the
     * specified inline query in the current chat's input field. Can be empty, in
     * which case only the bot's username will be inserted.
     *
     * This offers a quick way for the user to open your bot in inline mode in
     * the same chat – good for selecting something from multiple options.
     */
    get switchInlineQueryCurrentChat() {
        return this.payload.switch_inline_query_current_chat;
    }
    /**
     * Description of the game that will be launched when the user presses the
     * button.
     *
     * **NOTE**: This type of button **must** always be the first button in the
     * first row.
     */
    get callbackGame() {
        const { callback_game } = this.payload;
        if (!callback_game) {
            return;
        }
        return new callback_game_1.CallbackGame(callback_game);
    }
    /**
     * Specify `true`, to send a Pay button.
     *
     * **NOTE**: This type of button **must** always be the first button in the first row.
     */
    get pay() {
        return this.payload.pay;
    }
    toJSON() {
        return this.payload;
    }
};
__decorate([
    (0, inspectable_1.Inspect)()
], InlineKeyboardButton.prototype, "text", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], InlineKeyboardButton.prototype, "url", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], InlineKeyboardButton.prototype, "loginUrl", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], InlineKeyboardButton.prototype, "callbackData", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], InlineKeyboardButton.prototype, "switchInlineQuery", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], InlineKeyboardButton.prototype, "switchInlineQueryCurrentChat", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], InlineKeyboardButton.prototype, "callbackGame", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], InlineKeyboardButton.prototype, "pay", null);
InlineKeyboardButton = __decorate([
    (0, inspectable_1.Inspectable)()
], InlineKeyboardButton);
exports.InlineKeyboardButton = InlineKeyboardButton;

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Poll = void 0;
const inspectable_1 = require("inspectable");
const message_entity_1 = require("./message-entity");
const poll_option_1 = require("./poll-option");
/** This object contains information about a poll. */
let Poll = class Poll {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /** Unique poll identifier */
    get id() {
        return this.payload.id;
    }
    /** Poll question, `1-300` characters */
    get question() {
        return this.payload.question;
    }
    /** List of poll options */
    get options() {
        return this.payload.options.map(option => new poll_option_1.PollOption(option));
    }
    /** Total number of users that voted in the poll */
    get totalVoterCount() {
        return this.payload.total_voter_count;
    }
    /** `true`, if the poll is closed */
    isClosed() {
        return this.payload.is_closed;
    }
    /** `true`, if the poll is anonymous */
    isAnonymous() {
        return this.payload.is_anonymous;
    }
    /** Poll type, currently can be `regular` or `quiz` */
    get type() {
        return this.payload.type;
    }
    /** `true`, if the poll allows multiple answers */
    get allowsMultipleAnswers() {
        return this.payload.allows_multiple_answers;
    }
    /**
     * 0-based identifier of the correct answer option. Available only for polls
     * in the quiz mode, which are closed, or was sent (not forwarded) by the bot
     * or to the private chat with the bot.
     */
    get correctOptionId() {
        return this.payload.correct_option_id;
    }
    /**
     * Text that is shown when a user chooses an incorrect answer or taps on the
     * lamp icon in a quiz-style poll, 0-200 characters
     */
    get explanation() {
        return this.payload.explanation;
    }
    /**
     * Special entities like usernames, URLs, bot commands, etc. that appear in
     * the explanation
     */
    get explanationEntities() {
        const { explanation_entities } = this.payload;
        if (!explanation_entities) {
            return;
        }
        return explanation_entities.map(entity => new message_entity_1.MessageEntity(entity));
    }
    /** Amount of time in seconds the poll will be active after creation */
    get openPeriod() {
        return this.payload.open_period;
    }
    /**
     * Point in time (Unix timestamp) when the poll will be automatically closed
     */
    get closeDate() {
        return this.payload.close_date;
    }
    toJSON() {
        return this.payload;
    }
};
__decorate([
    (0, inspectable_1.Inspect)()
], Poll.prototype, "id", null);
__decorate([
    (0, inspectable_1.Inspect)()
], Poll.prototype, "question", null);
__decorate([
    (0, inspectable_1.Inspect)()
], Poll.prototype, "options", null);
__decorate([
    (0, inspectable_1.Inspect)()
], Poll.prototype, "totalVoterCount", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true })
], Poll.prototype, "isClosed", null);
__decorate([
    (0, inspectable_1.Inspect)({ compute: true })
], Poll.prototype, "isAnonymous", null);
__decorate([
    (0, inspectable_1.Inspect)()
], Poll.prototype, "type", null);
__decorate([
    (0, inspectable_1.Inspect)()
], Poll.prototype, "allowsMultipleAnswers", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Poll.prototype, "correctOptionId", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Poll.prototype, "explanation", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Poll.prototype, "explanationEntities", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Poll.prototype, "openPeriod", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Poll.prototype, "closeDate", null);
Poll = __decorate([
    (0, inspectable_1.Inspectable)()
], Poll);
exports.Poll = Poll;

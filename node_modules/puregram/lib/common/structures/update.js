"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Update = void 0;
const inspectable_1 = require("inspectable");
const callback_query_1 = require("./callback-query");
const chat_join_request_1 = require("./chat-join-request");
const chat_member_updated_1 = require("./chat-member-updated");
const chosen_inline_result_1 = require("./chosen-inline-result");
const inline_query_1 = require("./inline-query");
const message_1 = require("./message");
const poll_1 = require("./poll");
const poll_answer_1 = require("./poll-answer");
const pre_checkout_query_1 = require("./pre-checkout-query");
const shipping_query_1 = require("./shipping-query");
/**
 * This object represents an incoming update.
 *
 * At most **one** of the optional parameters can be present in any given
 * update.
 */
let Update = class Update {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * The update's unique identifier.
     * Update identifiers start from a certain positive number and increase
     * sequentially. This ID becomes especially handy if you're using
     * **Webhooks**, since it allows you to ignore repeated updates or to restore
     * the correct update sequence, should they get out of order. If there are no
     * new updates for at least a week, then identifier of the next update will
     * be chosen randomly instead of sequentially.
     */
    get id() {
        return this.payload.update_id;
    }
    /**
     * New incoming message of any kind — text, photo, sticker, etc.
     */
    get message() {
        const { message } = this.payload;
        if (!message) {
            return;
        }
        return new message_1.Message(message);
    }
    /** New version of a message that is known to the bot and was edited */
    get editedMessage() {
        const { edited_message } = this.payload;
        if (!edited_message) {
            return;
        }
        return new message_1.Message(edited_message);
    }
    /** New incoming channel post of any kind — text, photo, sticker, etc. */
    get channelPost() {
        const { channel_post } = this.payload;
        if (!channel_post) {
            return;
        }
        return new message_1.Message(channel_post);
    }
    /** New version of a channel post that is known to the bot and was edited */
    get editedChannelPost() {
        const { edited_channel_post } = this.payload;
        if (!edited_channel_post) {
            return;
        }
        return new message_1.Message(edited_channel_post);
    }
    /** New incoming inline query */
    get inlineQuery() {
        const { inline_query } = this.payload;
        if (!inline_query) {
            return;
        }
        return new inline_query_1.InlineQuery(inline_query);
    }
    /**
     * The result of an inline query that was chosen by a user and sent to their
     * chat partner. Please see our documentation on the feedback collecting for
     * details on how to enable these updates for your bot.
     */
    get chosenInlineResult() {
        const { chosen_inline_result } = this.payload;
        if (!chosen_inline_result) {
            return;
        }
        return new chosen_inline_result_1.ChosenInlineResult(chosen_inline_result);
    }
    /** New incoming callback query */
    get callbackQuery() {
        const { callback_query } = this.payload;
        if (!callback_query) {
            return;
        }
        return new callback_query_1.CallbackQuery(callback_query);
    }
    /** New incoming shipping query. Only for invoices with flexible price */
    get shippingQuery() {
        const { shipping_query } = this.payload;
        if (!shipping_query) {
            return;
        }
        return new shipping_query_1.ShippingQuery(shipping_query);
    }
    /**
     * New incoming pre-checkout query. Contains full information about checkout
     */
    get preCheckoutQuery() {
        const { pre_checkout_query } = this.payload;
        if (!pre_checkout_query) {
            return;
        }
        return new pre_checkout_query_1.PreCheckoutQuery(pre_checkout_query);
    }
    /**
     * New poll state. Bots receive only updates about stopped polls and polls,
     * which are sent by the bot
     */
    get poll() {
        const { poll } = this.payload;
        if (!poll) {
            return;
        }
        return new poll_1.Poll(poll);
    }
    /**
     * A user changed their answer in a non-anonymous poll. Bots receive new
     * votes only in polls that were sent by the bot itself.
     */
    get pollAnswer() {
        const { poll_answer } = this.payload;
        if (!poll_answer) {
            return;
        }
        return new poll_answer_1.PollAnswer(poll_answer);
    }
    /** The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user. */
    get myChatMember() {
        const { my_chat_member } = this.payload;
        if (!my_chat_member) {
            return;
        }
        return new chat_member_updated_1.ChatMemberUpdated(my_chat_member);
    }
    /**
     * A chat member's status was updated in a chat.
     *
     * The bot must be an administrator in the chat and must explicitly specify `chat_member` in the list of `allowed_updates` to receive these updates.
     */
    get chatMember() {
        const { chat_member } = this.payload;
        if (!chat_member) {
            return;
        }
        return new chat_member_updated_1.ChatMemberUpdated(chat_member);
    }
    /** A request to join the chat has been sent. The bot must have the `can_invite_users` administrator right in the chat to receive these updates. */
    get chatJoinRequest() {
        const { chat_join_request } = this.payload;
        if (!chat_join_request) {
            return;
        }
        return new chat_join_request_1.ChatJoinRequest(chat_join_request);
    }
    toJSON() {
        return this.payload;
    }
};
__decorate([
    (0, inspectable_1.Inspect)()
], Update.prototype, "id", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "message", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "editedMessage", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "channelPost", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "editedChannelPost", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "inlineQuery", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "chosenInlineResult", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "callbackQuery", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "shippingQuery", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "preCheckoutQuery", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "poll", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "pollAnswer", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "myChatMember", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "chatMember", null);
__decorate([
    (0, inspectable_1.Inspect)({ nullable: false })
], Update.prototype, "chatJoinRequest", null);
Update = __decorate([
    (0, inspectable_1.Inspectable)()
], Update);
exports.Update = Update;
